---
layout: post
title: Dijkstra算法整理 
---

通过整理笔记来增加对一些图算法的理解。

###问题描述
给定一个带权图（都是正值）和一个源点，求图上其他各点到源点的最短路径。

###算法描述
一种"贪心"的策略，依次遍历所有点，如果每次都能找到源点s到该点的最短路径，那么遍历完所有点就能解决这个问题。

	算法过程
	Dijkstra(G, w, s)
	{
		for u in V
			d[u] = ∞
			color[u] = white
		d[s] = 0
		createPriorityQueue(u, d[u])
		
		while Extract-Min(Q)
			for v in Adj(u)//这个遍历过程称为"松弛"过程
				if (d[u] + w[u, v] < d[v])
					d[v] = d[u] + w[u,v]
					DecreasedQ(v, d[v])
					pred[v] = u
			color[u] = black//表示已经处理完；
	}


###时间复杂度分析
创建优先队列的时间为O(VlogV);每次调用Extract-Min(Q)的时间是O(logV)，一共要处理V个顶点，那么就是（VlogV）。松弛过程中DecreasedQ的时间为O(logV);从全局过程来看，处理的就是所有的边，则总的时间复杂度为O(ElogV)。即最终的时间复杂度为O(VlogV) + O(logV) + O(ElogV) = O((E+V)logV)。
由于一般E>V，也可以写作O(ElogV)。

