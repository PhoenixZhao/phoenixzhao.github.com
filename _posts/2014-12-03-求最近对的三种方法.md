---
layout: post
title: 求最近点对的三种方法 
---

####问题描述：平面上的N个点，求这些点中距离（欧式距离）最小的一对点。
当然，这道题最直接的方法就是采用暴力求解，计算所有点的距离，找出最小的即可，这样所花的时间为O(N^2)。
这里要整理的三种方法，都会在**更短的的时间（O(NlogN)和O(N)）**来解决这个问题。

####Gridding Lemma:
这三个方法都是建立在Gridding Lemma的基础上。Lemma具体如下：

P = {p1, p2, ..., pn} 是一个点集， delta是要求的最近点对的距离。构造一个覆盖所有的网格平面，用水平和竖直的线将它切分为很多δ/2 × δ/2的小格子，则：

1. 每一个小正方形里最多只有一个点；
2. 对于任意一个点对，如果d(p, p') = δ， 那么这两个点在水平和竖直方向中间隔的正方形最多为1个。

这两个结论其实非常直接，对于(1)，如果一个格子里有两个点，这两个点的最大距离就是正方形对角线，这个值是小于最小距离δ的，显然不成立；
对（2），一旦达到2个格子或者更多，则两点距离肯定大于δ。

####方法一：Swipe-line算法
#####算法思路：
假设有一条垂直的直线，在平面上依次从左到右扫过，每次碰到一个点，就计算一下之前所有点之间的最小距离，这样当扫完所有的点的时候，也就找到了最小距离。

将所有的点按照X坐标排序，并标记为p1，p2, .., pn。**记P(i) = {p1, p2, .., pi}**， δ（P(i))为最近对的距离。当我们的直线扫到第i个点的时候，则有δ（P(i)） = min{δ(P(i-1), d(pi, P(i-1)))}，即如果加入了pi之后，最小距离变小，那么一定是pi和集合P(i-1)中的某一个点的距离。

而根据Gridding Lemma可知，如果存在d(pi, pi') < δ(P(i-1)), pi'在P(i-1)中，则pi'一定在直线向左垂直距离为2δ（X-2δ）的区域里（否则不可能小于的）。我们在此区域里**以pi为原点**构造δ/2 * δ/2的网状格子。那么pi'一定在pi的Y方向上下4个格子。记集合**S(i) = {p in P(i-1), pi.x - p.x <= δ}**,那么每次处理pi的时候，实际我们只需要考察S(i)中的最多8个点，即可计算出δ（P(i)） = min{δ(P(i-1), d(pi, P(i-1)))}。

如果我们每次能比较快地找出这8个点，计算最小距离就能在O(1)内完成。而找出这8个点的速度取决于S(i)的数据结构，很容易想到基于Y坐标的BST存储。这样查询pi的前后四个点就可以在O(logN)的时间内完成。


整个算法过程如下：

1.	将所有的点按照X坐标的升序排序，然后将它们记为p1 ,p2, p3, ..., pn；
2.	令δ(2) = d(p1, p2);S(2) = {p1}, 基于Y坐标构造S的BST。
3.	For i = 3 to n:

	3.1 当S(i-1)变为S(i)的时候，更新BST；
	
	3.2 从S(i)中找出pi的Y坐标上下4个点，求δ(P(i)) = min{δ(P(i-1), d(pi, P(i-1)))}。
	
	
程序终止时，δ(P(n))即为所求。

#####运行时间
1的时间为O(NlogN), 2的时间为O(1), 3.2的时间为O(logN)，则从3->n的总时间为O(NlogN)。接下来需要计算3.1的时间消耗。

可以证明，从3->n的过程，总消耗时间同样为O(NlogN)，证明如下：

1.	对于k < i， 如果pk不在S(i-1),那么pk之前的点（X坐标）肯定不在S(i-1)，因为X方向距离更大了。
2.	同时，如果pk不在S(i-1)中，那么pk肯定也不在S(i)中，因为pi.x - pk.x > p(i-1).x - pk.x >= δ(i-1)。

因此，从S(i-1)生成S(i)的过程如下：

1.	将p(i-1)加到BST存储的S(i-1)中；
2.	从左到右(X坐标)遍历S(i-1)，不停地删除，直到第一点满足S(i)的条件，作为S(i)新的左边界。

从这个过程中可以看出，所有的点最多只有一次insert和delete的操作，因此从3->n的walk through过程，对于算法中的3.1，我们最多进行N次的insert和N次的delete操作，因此时间复杂度为O(NlogN)。




