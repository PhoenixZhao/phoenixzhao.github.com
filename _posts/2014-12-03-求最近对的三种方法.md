---
layout: post
title: 求最近点对的三种方法 
---

###问题描述：平面上的N个点，求这些点中距离（欧式距离）最小的一对点。
当然，这道题最直接的方法就是采用暴力求解，计算所有点的距离，找出最小的即可，这样所花的时间为O(N^2)。
这里要整理的三种方法，都会在**更短的的时间（O(NlogN)和O(N)）**来解决这个问题。

###Gridding Lemma:
这三个方法都是建立在Gridding Lemma的基础上。Lemma具体如下：

P = {p1, p2, ..., pn} 是一个点集，δ是要求的最近点对的距离。构造一个覆盖所有的网格平面，用水平和竖直的线将它切分为很多δ/2 × δ/2的小格子，则：

1. 每一个小正方形里最多只有一个点；
2. 对于任意一个点对，如果d(p, p') = δ， 那么这两个点在水平和竖直方向中间隔的正方形最多为1个。

这两个结论其实非常直接，对于(1)，如果一个格子里有两个点，这两个点的最大距离就是正方形对角线，这个值是小于最小距离δ的，显然不成立；
对（2），一旦达到2个格子或者更多，则两点距离肯定大于δ。

###方法一：Swipe-line算法
####思路：
假设有一条垂直的直线，在平面上依次从左到右扫过，每次碰到一个点，就计算一下该点到之前所有点之间的最小距离，这样当扫完所有的点的时候，也就找到了最小距离。

将所有的点按照X坐标排序，并标记为p1，p2, .., pn。**记P(i) = {p1, p2, .., pi}**， δ（P(i))为最近对的距离。当我们的直线扫到第i个点的时候，则有δ（P(i)） = min{δ(P(i-1), d(pi, P(i-1)))}，即如果加入了pi之后，最小距离变小，那么一定是pi和集合P(i-1)中的某一个点的距离。

而根据Gridding Lemma可知，如果存在d(pi, pi') < δ(P(i-1)), pi'在P(i-1)中，则pi'一定在直线向左垂直距离为2δ（X-2δ）的区域里（否则不可能小于的）。我们在此区域里**以pi为原点**构造δ/2 * δ/2的网状格子。那么pi'一定在pi的Y方向上下4个格子。记集合**S(i) = {p in P(i-1), pi.x - p.x <= δ}**,那么每次处理pi的时候，实际我们只需要考察S(i)中的最多8个点，即可计算出δ（P(i)） = min{δ(P(i-1), d(pi, P(i-1)))}。

如果我们每次能比较快地找出这8个点，计算最小距离就能在O(1)内完成。而找出这8个点的速度取决于S(i)的数据结构，很容易想到基于Y坐标的BST存储。这样查询pi的前后四个点就可以在O(logN)的时间内完成。


####算法过程：

1.	将所有的点按照X坐标的升序排序，然后将它们记为p1 ,p2, p3, ..., pn；
2.	令δ(2) = d(p1, p2);S(2) = {p1}, 基于Y坐标构造S的BST。
3.	For i = 3 to n:

	3.1 当S(i-1)变为S(i)的时候，更新BST；
	
	3.2 从S(i)中找出pi的Y坐标上下4个点，求δ(P(i)) = min{δ(P(i-1), d(pi, P(i-1)))}。
	
	
程序终止时，δ(P(n))即为所求。

####运行时间
1的时间为O(NlogN), 2的时间为O(1), 3.2的时间为O(logN)，则从3->n的总时间为O(NlogN)。接下来需要计算3.1的时间消耗。

可以证明，从3->n的过程，总消耗时间同样为O(NlogN)，证明如下：

1.	对于k < i， 如果pk不在S(i-1),那么pk之前的点（X坐标）肯定不在S(i-1)，因为X方向距离更大了。
2.	同时，如果pk不在S(i-1)中，那么pk肯定也不在S(i)中，因为pi.x - pk.x > p(i-1).x - pk.x >= δ(i-1)。

因此，从S(i-1)生成S(i)的过程如下：

1.	将p(i-1)加到BST存储的S(i-1)中；
2.	从左到右(X坐标)遍历S(i-1)，不停地删除，直到第一点满足S(i)的条件，作为S(i)新的左边界。

从这个过程中可以看出，所有的点最多只有一次insert和delete的操作，因此从3->n的walk through过程，对于算法中的3.1，我们最多进行N次的insert和N次的delete操作，因此时间复杂度为O(NlogN)。


###方法二：分治
####思路
对于分治法来说，一个比较直观的思路就是将这些点分成P(L), P(R)两部分，先找P(L)和P(R)的最小点对，然后再找P(L)和P(R)之间的最小点对，比较求出最小。将此过程递归下去，递归终点是当N<=3的时候，直接暴力求解即可。

用分治法，要想达到O(NlogN)的时间复杂度，必须得到T(N) = 2T(N/2) + O(N)的递推式。那么关键在于求δ(P(L), P(R))。在一次递归中，设直线l将所有的点按照X坐标分为P(L), P(R)，令δ = min{δ(P(L)), δ(P(R))}。那么如果存在δ(P(L), P(R)) < δ，那么这两个点必定在以直线l为中心，宽度为δ的区域范围内，如果将分布在这个区域里的所有点按照Y坐标排序，然后从小到大依次遍历这些点，对于每个点p来说，我们只需要考虑它随后的7个点即可。原因是在一个δ * 2δ的矩形区域里，最多只可能存在8个点，否则δ不满足P(L)和P(R)的最小点对距离。

那么现在的问题就是，如何在每次递归的过程中，保证点集都是基于X和Y坐标有序的，因为这样就可以在线性时间内，完成P(L)和P(R)的划分，并且非常容易地找到δ*2δ区域里每个点之后的7个点。一个最简单的方法就是**预排序**，使用O(NlogN)的排序方法将所有的点按照X和Y坐标排序好，这样就可以得到T'(N) = T(N) + O(NlogN)， 而T(N) = T(N) = 2T(N/2) + O(N),即T(N) = O(NlogN),则T'(N) = O(NlogN)。

这部分内容可以参考《算法导论》Chapter 33.4


###方法三：基于哈希的随机算法

随机算法涉及到概率论的一些知识，并且最终的时间是期望值，衡量的并不是一次执行的时间，而是多次执行之后的平均时间。这一点需要注意。

随机算法主要体现在两点：
1，对输入的N个点，随机将它们标记为p1, p2, ..., pn;
2，这里的hash使用的是基于随机算法生成的universal hash，能够最大限度保证查询和插入的时间都为O(1),在这里不阐述过多的细节，后续会重新整理一篇关于universal hash的文章。

####思路
对于随机标记之后的点，遍历一遍，找出坐标中的x_min, x_max, y_min, y_max，然后令p0=(x_min, y_min)，D=max{x_max - x_min, y_max - y_min}。以P0为原点，D为边长，构造一个正方形，那么所有的点都在这个正方形区域里。

按照距离d将正方形分成很多网格，每个格子使用一个坐标（X, Y）表示，它包含的点为X<=x<X+d, Y<=y<=Y+d,即对于任何一个点(x,y)，它所处的网格为((x-x_min)/d, (y-y_min)/d)。

利用这个关系构造哈希，那么每个点都能找到一个特定的位置与之对应。

接下来，类似Swipe-line算法，构造P(i) = {p1, p2, ..., pi}, δ(i) = δ(P(i))，网格的大小d=δ(i)/2;则根据Gridding Lemma，每个网格中最多只有一个点；

同样有，δ(i) = min{δ(i-1), d(pi),P(i-1))}。对于点pi来说，如果存在d(pi, p) < δ(i-1), p in P(i-1)，那么根据Gridding Lemma，p一定在以pi为中心的周围25个格子的点中。因此每次我们只需要考虑这25个点即可，而通过hash，可以保证每次查询的时间成本为O(1)。

一旦找到d(pi，p) < δ(i-1)，则需要将pi加入到grid中，然后以d(pi, p)/2为d重新构建网格；继续后面的操作，否则只需要将p(i)加入到原网格中即可；


####算法过程
1.	将所有的点随机标记为p1, p2, ..., pn,遍历一遍，找出x_min, x_max, y_min, y_max;
2.	令δ(2) = d(p1, p2)， d=δ(2)/2，将P(2)通过hash放入d分割的正方形区域中；
3.	i from 3->n，

	3.1 找出p_i+1与其周围25个点的最小距离d_min；
	
		3.2.1 if d_min > δ(i), δ(i+1)=δ(i),并将p_i+1插入网格中；
		3.2.2 if d_min < δ(i), δ(i+1)=d_min，并使用d'=δ(i+1)/2重构网格并对于P(i+1)中所有
		点重新放入新的位置
		
算法完成后，δ(n)即为所求；

####运行时间分析
步骤1的时间为O(N),步骤2的时间为O(1),步骤3.1的时间为O(N),i从3到n。

对于3.2的分析，我们来看3.2.2，对于点 集P(i+1) = {p1, p2, ..., p_i+1}，对于d(pj, pk), j<=i+1, k<=i+1, 如果存在d(pj, pk) < δ(i)，则要么j=i+1, 或者k=i+1。
	
所有的点都是随机标记的，那么Prob(d(pj, pk) < δ(i)) <= 2\*i / (i+1)\*i = 2/(i+1)。

即随机变量Xi为3.2.2中n=i时需要进行的操作数；则Prob(Xi=0) = 1 - 2(i+1), Prob(Xi=O(i+1)) = 2/(i+1)，则可以求出E(Xi) = O(i+1) * 2/(i+1) = O(1)。因此当i从3到n的时候，3.2.2的时间复杂度为O(N),即可以推出所有的时间复杂度为：T(n) = O(N) + O(1) + O(N) + O(N) = O(N)





