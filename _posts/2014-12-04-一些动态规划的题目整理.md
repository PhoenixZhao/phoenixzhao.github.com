---
layout: post
title: 一些动态规划的题目整理 
---

将最近学到的动态规划的问题整理到一起，慢慢体会DP的奥妙。

###1. Rod Cutting问题
####问题描述：
给定一个长度为n的绳子，以及一个映射表T，for i = 1, 2, ..., n p(i)表示长度为i的价值。求如何切绳子，能产生最大的价值。

####常规做法
直接暴力遍历所有的情况，时间复杂度为T(2^n)。

####动态规划
####思路
将绳子切为两段p, q, p+q=n，那么要使最终的价值最大，那么一定要保证p和q分别获得最大价值。这样就得到了子问题。
S(i) = max{S(k) + S(i-k)}, k from 0 to i;

而当我们自底向上计算的时候，每次计算求解i的时候，S(k)在之前的步骤中已经算好了，只需要查表就可以，因此问题得以优化；

####过程
{% highlight c %}
Rod_Cutting(p, n){
	r[0] = 0;
	for (i = 1; i <= n; i++){
		S = -1
		for (j = 0; j<=i; j++){
			if (p[j] + r[i-j] > S)
				S = p[j] + r[i-j]
		}
		r[i] = S
	}
	return r[n]
}

{% endhighlight %}
####复杂度
O(N^2)

###2.Chain Matrix Multiplication
####问题描述 
给定N个矩阵，求计算顺序，使得求解A1A2A3...AN的计算次数最少。
####动态规划
####思路
这题如果用暴力方法做的话，当n比较大的话，计算复杂度基本没法接受。动态规划最重要的就是找到对应的最优子问题，然后采用自底向上的方法，逐步求解即可。

对于两个矩阵A(p\*q), B(q\*r)，计算次数为pqr。

而对于一个矩阵相乘序列A1A2A3...AN，最终的结果是一个矩阵A，最后一次的相乘肯定是两个矩阵AiAj相乘，而AiAj是由这个矩阵序列的子序列相乘得到，如果要是的最终得到A的计算次数最小，那么计算Ai的次数对于该序列一定也是最优的，否则我们可以用一个更优的计算方法来求解Ai。这样就找到我们需要的子问题。

用Ai...j表示矩阵序列AiAi+1...Aj(i<j), 用m[i][j]表示计算Ai...j的最小次数，那么
m[i][j] = min{m[i][k] + m[k][j] + p(i-1)p(k)p(j)}, i<= k < j, Ai...j最终是一个p(i-1)*p(j)的矩阵;意味着当我们求得到最后一步的两个矩阵需要遍历所有可能的分界点，将Ai...j分成两个子序列。

然后采用自底向上的方法，每次比较的时候,m[i][k], m[k][j]已经在之前的步骤中计算得到。我们需要按照如下过程求解m[i][j](下面用m[i,j]代表m[i][j]):

	m[1,2],m[2,3],m[3,4],...
	m[1,3],m[2,4],m[3,5],...
	m[1,4],m[2,5],m[3,6],...
	...

####过程
{% highlight c %}
Matrix_Chain(p, n){
	for (i=0; i<=n; i++)
		m[i][i] = 0;
	for (l=1; l < n; l++)
		for(i=1;i< n;i++)
			j = i + l;
			for (k=i;k<j;k++){
				if (m[i][j] > (m[i][k] + m[k][j] + p[i-1]p[k]\*p[j]))
					m[i][j] = m[i][k] + m[k][j] + p[i-1]p[k]\*p[j];
					s[j][j] = k;
			}
	return m, s;
}
{% endhighlight %}

####复杂度
时间：O(N^3)， 空间：O(N^2)

###3.最长公共子序列&最长公共子串

####问题描述
#####最长公共子序列
给定两个字符串X,Y,找出两个字符串中公共部分最长的子序列，不需要连续；如X: abcbdad; Y: bdcaba;那么最长公共子序列为bcba;
#####最长公共子串
给定两个字符串X,Y,找出两个字符串中相同的最长的子串，即需要连续；如X: abcbdad; Y: bdcaba;那么最长公共子串为ab;
####思路
这两道题算是非常经典的DP问题，求解思路同样需要先找子结构；

对于**最长公共子序列**，我们需要比较X和Y的最后一个字符，记为X[i], Y[j]，同时记Z为最长公共子序列，则

	当X[i] = Y[j], Z = 1 + LCS(X[i-1], Y[j-1]);
	当X[i] ≠ Y[j], Z = max{LCS(X(i-1), Y(j), LCS(X(i), Y(j-1)))}

记d[i,j]=LCS(X(i), Y(j));则d[i,j] = max{d[i, j-1], d[i-1, j], X[i]&Y[j] + d[i-1, j-1]}

采取自底向上的方法，即可求出X和Y的最长公共子序列；

{% highlight c %}
LCS(X, Y){
	m = length(X);
	n = length(Y);
	for (i=0;i<=m;i++)
		d[i][0] = 0;
	for (i=0;i<=n;i++)
		d[0][n] = 0;
	for (i=1;i<=m;i++)
		for (j=1;j<=n;j++)
			if (X[i] == Y[j])
				d[i][j] = 1 + d[i-1][j-1]
				label[i][j] = "LU"
			else
				if (d[i-1][j] >= d[i][j-1])
					d[i][j] = d[i-1][j];
					label[i][j] = "L";
				else
					d[i][j] = d[i][j-1];
					label[i][j] = "U";
	return d[m][n]
}
{% endhighlight %}

####易得时间复杂度为O(mn);

对于**最长公共子串**，当我们定义同样的子问题的时候，即d[i,j]表示X[i], Y[j]的最长公共子串的长度的时候，无法解决此问题，所以需要寻找另外的子问题。

定义d[i,j]表示X(i)和Y(j)的最长公共子串以X[i],Y[j]为结尾字符，那么

	当X[i] = Y[j]时，d[i,j] = 1 + d[i-1,j-1];
	当X[i] ≠ Y[j]时，d[i,j] = 0;(表示最长公共子串不可能以X[i], Y[j]为结尾字符)
	
接下来就需要自底向上，求LCS(X,Y) = max{d[i, j]}

{% highlight c %}
LCS(X, Y){
	m = length(X);
	n = length(Y);
	for (i=0;i<=m;i++)
		d[i][0] = 0;
	for (i=0;i<=n;i++)
		d[0][n] = 0;
	max = 0;
	for (i=1;i<=m;i++)
		for (j=1;j<=n;j++)
			if (X[i] == Y[j])
				d[i][j] = 1 + d[i-1][j-1]
				if d[i][j] > max
					max = d[i][j];
					pmax = i;
					//同时要记录d[i-1][j-1]的位置,表示子串的一部分
			else
				d[i][j] = 0;
	return max, pmax;
}
{% endhighlight %}

####同样易得时间复杂度为O(mn);







