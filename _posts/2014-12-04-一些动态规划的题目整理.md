---
layout: post
title: 一些动态规划的题目整理 
---

将最近学到的动态规划的问题整理到一起，慢慢体会DP的奥妙。

###Rod Cutting问题
####问题描述：
给定一个长度为n的绳子，以及一个映射表T，for i = 1, 2, ..., n p(i)表示长度为i的价值。求如何切绳子，能产生最大的价值。

####常规做法
直接暴力遍历所有的情况，时间复杂度为T(2^n)。

####动态规划
######思路
将绳子切为两段p, q, p+q=n，那么要使最终的价值最大，那么一定要保证p和q分别获得最大价值。这样就得到了子问题。
S(i) = max{S(k) + S(i-k)}, k from 0 to i;

而当我们自底向上计算的时候，每次计算求解i的时候，S(k)在之前的步骤中已经算好了，只需要查表就可以，因此问题得以优化；

#####过程
{% highlight c %}
Rod_Cutting(p, n){
	r[0] = 0;
	for (i = 1; i <= n; i++){
		S = -1
		for (j = 0; j<=i; j++){
			if (p[j] + r[i-j] > S)
				S = p[j] + r[i-j]
		}
		r[i] = S
	}
	return r[n]
}

{% endhighlight %}
#####复杂度
O(N^2)

###Chain Matrix Multiplication
####问题描述 
给定N个矩阵，求计算顺序，使得求解A1A2A3...AN的计算次数最少。
####动态规划
#####思路
这题如果用暴力方法做的话，当n比较大的话，计算复杂度基本没法接受。动态规划最重要的就是找到对应的最优子问题，然后采用自底向上的方法，逐步求解即可。

对于两个矩阵A(p\*q), B(q\*r)，计算次数为pqr。

而对于一个矩阵相乘序列A1A2A3...AN，最终的结果是一个矩阵A，最后一次的相乘肯定是两个矩阵AiAj相乘，而AiAj是由这个矩阵序列的子序列相乘得到，如果要是的最终得到A的计算次数最小，那么计算Ai的次数对于该序列一定也是最优的，否则我们可以用一个更优的计算方法来求解Ai。这样就找到我们需要的子问题。

用Ai...j表示矩阵序列AiAi+1...Aj(i<j), 用m[i][j]表示计算Ai...j的最小次数，那么
m[i][j] = min{m[i][k] + m[k][j] + p(i-1)p(k)p(j)}, i<= k < j, Ai...j最终是一个p(i-1)*p(j)的矩阵;意味着当我们求得到最后一步的两个矩阵需要遍历所有可能的分界点，将Ai...j分成两个子序列。

然后采用自底向上的方法，每次比较的时候,m[i][k], m[k][j]已经在之前的步骤中计算得到。我们需要按照如下过程求解m[i][j](下面用m[i,j]代表m[i][j]):

	m[1,2],m[2,3],m[3,4],...
	m[1,3],m[2,4],m[3,5],...
	m[1,4],m[2,5],m[3,6],...
	...

####过程
{% highlight c %}
Matrix_Chain(p, n){
	for (i=0; i<=n; i++)
		m[i][i] = 0;
	for (l=1; l < n; l++)
		for(i=1;i< n;i++)
			j = i + l;
			for (k=i;k<j;k++){
				if (m[i][j] > (m[i][k] + m[k][j] + p[i-1]p[k]\*p[j]))
					m[i][j] = m[i][k] + m[k][j] + p[i-1]p[k]\*p[j];
					s[j][j] = k;
			}
	return m, s;
}
{% endhighlight %}








